import { supabase } from '@/integrations/supabase/client'
import QRCode from 'qrcode'
import { EmailService } from './EmailService'

// Type assertion for supabase client to work with our database
const db = supabase as any

// Define types based on our database schema
interface Ticket {
  id: string
  ticket_type_id: string
  event_id: string
  holder_email: string
  holder_name: string | null
  holder_phone: string | null
  status: 'active' | 'used' | 'refunded' | 'cancelled'
  qr_code: string
  checked_in_at: string | null
  checked_in_by: string | null
  created_at: string
  updated_at: string
}

interface TicketInsert {
  id?: string
  ticket_type_id: string
  event_id: string
  holder_email: string
  holder_name?: string | null
  holder_phone?: string | null
  status?: 'active' | 'used' | 'refunded' | 'cancelled'
  qr_code?: string
  checked_in_at?: string | null
  checked_in_by?: string | null
  created_at?: string
  updated_at?: string
}

interface Order {
  id: string
  event_id: string
  customer_email: string
  customer_name: string | null
  customer_phone: string | null
  total_amount: number
  payment_status: 'pending' | 'completed' | 'failed' | 'refunded'
  payment_intent_id: string | null
  payment_method: string | null
  created_at: string
  updated_at: string
}

interface OrderItem {
  id: string
  order_id: string
  ticket_type_id: string
  quantity: number
  unit_price: number
  total_price: number
  created_at: string
}

export interface QRCodeData {
  ticketId: string
  eventId: string
  orderId: string
  holderName: string
  holderEmail: string
  ticketType: string
  eventTitle: string
  eventDate: string
  eventTime: string
  venue: string
  validationHash: string
}

export interface GenerateTicketsRequest {
  order: Order
  orderItems: OrderItem[]
  eventDetails?: {
    title: string
    date: string
    time: string
    location: string
  }
}

export interface GenerateTicketsResponse {
  tickets: Ticket[]
  success: boolean
  error?: string
  emailSent?: boolean
  emailError?: string
}

export class TicketService {
  /**
   * Generate individual tickets after order creation
   */
  static async generateTickets(request: GenerateTicketsRequest): Promise<GenerateTicketsResponse> {
    try {
      const { order, orderItems } = request
      const allTickets: Ticket[] = []

      // Get event details if not provided
      let eventDetails = request.eventDetails
      if (!eventDetails) {
        const { data: event, error: eventError } = await supabase
          .from('events')
          .select('title, date, time, location')
          .eq('id', order.event_id)
          .single()

        if (eventError || !event) {
          throw new Error(`Failed to fetch event details: ${eventError?.message}`)
        }
        eventDetails = event
      }

      // Process each order item to create individual tickets
      for (const orderItem of orderItems) {
        // Get ticket type details
        const { data: ticketType, error: ticketTypeError } = await db
          .from('ticket_types')
          .select('name, description')
          .eq('id', orderItem.ticket_type_id)
          .single()

        if (ticketTypeError || !ticketType) {
          throw new Error(`Failed to fetch ticket type: ${ticketTypeError?.message}`)
        }

        // Create individual tickets based on quantity
        const ticketsToCreate: TicketInsert[] = []
        
        for (let i = 0; i < orderItem.quantity; i++) {
          const ticketData: TicketInsert = {
            ticket_type_id: orderItem.ticket_type_id,
            event_id: order.event_id,
            holder_email: order.customer_email,
            holder_name: order.customer_name,
            holder_phone: order.customer_phone,
            status: 'active',
            // QR code will be generated by the database trigger initially
            // We'll enhance it after ticket creation
          }

          ticketsToCreate.push(ticketData)
        }

        // Insert tickets into database
        const { data: createdTickets, error: ticketError } = await db
          .from('tickets')
          .insert(ticketsToCreate)
          .select()

        if (ticketError || !createdTickets) {
          throw new Error(`Failed to create tickets: ${ticketError?.message}`)
        }

        // Enhance QR codes with comprehensive data for each ticket
        for (const ticket of createdTickets) {
          const enhancedQRCode = await this.generateEnhancedQRCode({
            ticketId: ticket.id,
            eventId: order.event_id,
            orderId: order.id,
            holderName: order.customer_name || 'Guest',
            holderEmail: order.customer_email,
            ticketType: ticketType.name,
            eventTitle: eventDetails.title,
            eventDate: eventDetails.date,
            eventTime: eventDetails.time,
            venue: eventDetails.location,
            validationHash: this.generateValidationHash(ticket.id, order.id),
          })

          // Update ticket with enhanced QR code
          const { error: updateError } = await db
            .from('tickets')
            .update({ qr_code: enhancedQRCode })
            .eq('id', ticket.id)

          if (updateError) {
            console.error(`Failed to update QR code for ticket ${ticket.id}:`, updateError)
            // Don't throw error - ticket is still created, just with basic QR code
          } else {
            // Update the ticket object with the new QR code
            ticket.qr_code = enhancedQRCode
          }
        }

        allTickets.push(...createdTickets)
      }

      // Update sold quantity for ticket types
      await this.updateSoldQuantities(orderItems)

      // Send email notification
      const emailResult = await this.sendTicketEmail(order, allTickets, eventDetails)

      return {
        tickets: allTickets,
        success: true,
        emailSent: emailResult.success,
        emailError: emailResult.error,
      }

    } catch (error) {
      console.error('TicketService.generateTickets failed:', error)
      return {
        tickets: [],
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      }
    }
  }

  /**
   * Generate enhanced QR code with comprehensive event and ticket data
   */
  private static async generateEnhancedQRCode(data: QRCodeData): Promise<string> {
    try {
      // Create QR code data object
      const qrData = {
        v: '1.0', // Version for future compatibility
        t: data.ticketId,
        e: data.eventId,
        o: data.orderId,
        h: data.holderEmail,
        n: data.holderName,
        tt: data.ticketType,
        et: data.eventTitle,
        d: data.eventDate,
        tm: data.eventTime,
        ven: data.venue,
        hash: data.validationHash,
        ts: new Date().toISOString(), // Timestamp for when QR was generated
      }

      // Convert to JSON string for QR code
      const qrString = JSON.stringify(qrData)
      
      // Generate QR code as data URL
      const qrCodeDataURL = await QRCode.toDataURL(qrString, {
        errorCorrectionLevel: 'M',
        type: 'image/png',
        quality: 0.92,
        margin: 1,
        color: {
          dark: '#000000',
          light: '#FFFFFF'
        },
        width: 256,
      })

      return qrCodeDataURL

    } catch (error) {
      console.error('Failed to generate enhanced QR code:', error)
      // Fallback to simple QR code
      return `QR_${data.ticketId}`
    }
  }

  /**
   * Generate validation hash for security
   */
  private static generateValidationHash(ticketId: string, orderId: string): string {
    const data = `${ticketId}-${orderId}-${Date.now()}`
    // Simple hash - in production, use a proper cryptographic hash
    let hash = 0
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i)
      hash = ((hash << 5) - hash) + char
      hash = hash & hash // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(16)
  }

  /**
   * Update sold quantities for ticket types
   */
  private static async updateSoldQuantities(orderItems: OrderItem[]): Promise<void> {
    try {
      for (const item of orderItems) {
        // Try using the RPC function first
        const { error: rpcError } = await db.rpc('increment_sold_quantity', {
          ticket_type_id: item.ticket_type_id,
          quantity_to_add: item.quantity,
        })

        if (rpcError) {
          // Fallback: Get current value and update
          console.warn(`RPC function not available, using fallback update for ticket type ${item.ticket_type_id}`)
          
          const { data: ticketType, error: fetchError } = await db
            .from('ticket_types')
            .select('sold_quantity')
            .eq('id', item.ticket_type_id)
            .single()

          if (!fetchError && ticketType) {
            const { error: updateError } = await db
              .from('ticket_types')
              .update({
                sold_quantity: ticketType.sold_quantity + item.quantity,
              })
              .eq('id', item.ticket_type_id)

            if (updateError) {
              console.error(`Failed to update sold quantity for ticket type ${item.ticket_type_id}:`, updateError)
            }
          } else {
            console.error(`Failed to fetch current sold quantity for ticket type ${item.ticket_type_id}:`, fetchError)
          }
        }
      }
    } catch (error) {
      console.error('Failed to update sold quantities:', error)
    }
  }

  /**
   * Get tickets for a specific customer
   */
  static async getTicketsByCustomer(customerEmail: string): Promise<Ticket[]> {
    try {
      const { data: tickets, error } = await db
        .from('tickets')
        .select(`
          *,
          ticket_types (
            name,
            description,
            price
          ),
          events (
            title,
            date,
            time,
            location,
            organization_name
          )
        `)
        .eq('holder_email', customerEmail)
        .order('created_at', { ascending: false })

      if (error) {
        throw new Error(`Failed to fetch tickets: ${error.message}`)
      }

      return tickets || []
    } catch (error) {
      console.error('TicketService.getTicketsByCustomer failed:', error)
      return []
    }
  }

  /**
   * Get a specific ticket by ID
   */
  static async getTicketById(ticketId: string): Promise<Ticket | null> {
    try {
      const { data: ticket, error } = await db
        .from('tickets')
        .select(`
          *,
          ticket_types (
            name,
            description,
            price
          ),
          events (
            title,
            date,
            time,
            location,
            organization_name
          )
        `)
        .eq('id', ticketId)
        .single()

      if (error) {
        throw new Error(`Failed to fetch ticket: ${error.message}`)
      }

      return ticket
    } catch (error) {
      console.error('TicketService.getTicketById failed:', error)
      return null
    }
  }

  /**
   * Validate a ticket by QR code data
   */
  static async validateTicket(qrCodeData: string): Promise<{
    valid: boolean
    ticket?: Ticket
    error?: string
  }> {
    try {
      let ticketData: any

      // Try to parse as JSON (enhanced QR code)
      try {
        ticketData = JSON.parse(qrCodeData)
      } catch {
        // Fallback for simple QR codes (QR_ticketId format)
        if (qrCodeData.startsWith('QR_')) {
          const ticketId = qrCodeData.replace('QR_', '')
          const ticket = await this.getTicketById(ticketId)
          return {
            valid: !!ticket && ticket.status === 'active',
            ticket: ticket || undefined,
            error: !ticket ? 'Ticket not found' : undefined,
          }
        }
        throw new Error('Invalid QR code format')
      }

      // Validate enhanced QR code
      if (!ticketData.t || !ticketData.hash) {
        throw new Error('Invalid QR code data')
      }

      const ticket = await this.getTicketById(ticketData.t)
      if (!ticket) {
        return {
          valid: false,
          error: 'Ticket not found',
        }
      }

      // Validate hash (simple check)
      const expectedHash = this.generateValidationHash(ticket.id, ticketData.o)
      if (ticketData.hash !== expectedHash) {
        return {
          valid: false,
          error: 'Invalid ticket - security check failed',
        }
      }

      return {
        valid: ticket.status === 'active',
        ticket,
        error: ticket.status !== 'active' ? `Ticket status: ${ticket.status}` : undefined,
      }

    } catch (error) {
      console.error('TicketService.validateTicket failed:', error)
      return {
        valid: false,
        error: error instanceof Error ? error.message : 'Validation failed',
      }
    }
  }

  /**
   * Check in a ticket (mark as used)
   */
  static async checkInTicket(
    ticketId: string, 
    checkedInBy?: string
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const { error } = await db
        .from('tickets')
        .update({
          status: 'used',
          checked_in_at: new Date().toISOString(),
          checked_in_by: checkedInBy || null,
        })
        .eq('id', ticketId)
        .eq('status', 'active') // Only check in active tickets

      if (error) {
        throw new Error(`Failed to check in ticket: ${error.message}`)
      }

      return { success: true }
    } catch (error) {
      console.error('TicketService.checkInTicket failed:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Check-in failed',
      }
    }
  }

  /**
   * Send ticket confirmation email
   */
  private static async sendTicketEmail(
    order: Order,
    tickets: Ticket[],
    eventDetails: { title: string; date: string; time: string; location: string }
  ): Promise<{ success: boolean; error?: string }> {
    try {
      // Prepare email data
      const emailData = {
        customerName: order.customer_name || 'Guest',
        customerEmail: order.customer_email,
        eventTitle: eventDetails.title,
        eventDate: eventDetails.date,
        eventTime: eventDetails.time,
        eventLocation: eventDetails.location,
        tickets: tickets.map(ticket => ({
          id: ticket.id,
          ticketType: 'General Admission', // This would come from ticket_types join
          qrCode: ticket.qr_code,
          holderName: ticket.holder_name || order.customer_name || 'Guest',
        })),
        orderTotal: order.total_amount,
        orderId: order.id,
      }

      const result = await EmailService.sendTicketConfirmation(emailData)
      return result

    } catch (error) {
      console.error('Failed to send ticket email:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Email sending failed',
      }
    }
  }

  /**
   * Cancel a ticket (mark as cancelled)
   */
  static async cancelTicket(ticketId: string): Promise<{ success: boolean; error?: string }> {
    try {
      const { error } = await db
        .from('tickets')
        .update({
          status: 'cancelled',
          updated_at: new Date().toISOString(),
        })
        .eq('id', ticketId)

      if (error) {
        throw new Error(`Failed to cancel ticket: ${error.message}`)
      }

      return { success: true }
    } catch (error) {
      console.error('TicketService.cancelTicket failed:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Cancellation failed',
      }
    }
  }
}